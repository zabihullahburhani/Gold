

backend/
├── app/
│   ├── api/
│   │   └── v1/
│   │       ├── auth.py         # برای لاگین، ثبت‌نام، توکن
│   │       └── users.py        # عملیات روی یوزرها
│   ├── core/
│   │   ├── config.py          # تنظیمات
│   │   └── security.py       # JWT, Hashing
|    |    |-- database.py
│   ├── crud/
│   │   └── user.py           # عملیات دیتابیس برای یوزرها
│   ├── models/
│   │   └── user.py           # مدل ORM برای User
│   ├── schemas/
│   │   └── user.py           # Pydantic models
│   └── main.py              # نقطه شروع
├── alembic/                 # migration دیتابیس
├── alembic.ini
├── requirements.txt
└── .env

# backend/app/api/v1/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime

from app.core.database import get_db
from app.core.security import verify_password, create_access_token
from app.crud.user import get_login_by_username
from app.schemas.user import LoginIn, TokenOut

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])

@router.post("/login", response_model=TokenOut)
def login(payload: LoginIn, db: Session = Depends(get_db)):
    login_row = get_login_by_username(db, payload.username)
    if not login_row or not verify_password(payload.password, login_row.password_hash):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")

    # نقش از employee
    role = login_row.employee.role if login_row.employee else "user"

    # ساخت توکن با sub و role
    token = create_access_token({"sub": login_row.username, "role": role})

    # ثبت آخرین ورود
    login_row.last_login = datetime.utcnow()
    db.add(login_row)
    db.commit()

    return {"access_token": token, "token_type": "bearer", "role": role}

# created by: professor zabihullah burhani
# ICT and AI and Robotics متخصص
# phone: 0705002913, email: zabihullahburhani@gmail.com
# Address: Takhar University, COmputer science faculty.


# backend/app/api/v1/users.py
from fastapi import APIRouter, Depends, HTTPException, Form
from sqlalchemy.orm import Session
from app.schemas.user import EmployeeCreate, EmployeeUpdate, EmployeeOut, LoginIn, TokenOut
from app.crud import user as crud
from app.core.database import get_db
from app.core.security import verify_password, create_access_token

router = APIRouter(prefix="/employees", tags=["Employees"])

# ایجاد کارمند
@router.post("/", response_model=EmployeeOut)
def create_employee(emp: EmployeeCreate, db: Session = Depends(get_db)):
    return crud.create_employee(db, emp)

# گرفتن لیست همه کارمندان
@router.get("/", response_model=list[EmployeeOut])
def list_employees(db: Session = Depends(get_db)):
    return crud.get_employees(db)

# گرفتن کارمند با ID
@router.get("/{employee_id}", response_model=EmployeeOut)
def get_employee(employee_id: int, db: Session = Depends(get_db)):
    emp = crud.get_employee(db, employee_id)
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    return emp

# آپدیت کارمند
@router.put("/{employee_id}", response_model=EmployeeOut)
def update_employee(employee_id: int, data: EmployeeUpdate, db: Session = Depends(get_db)):
    emp = crud.update_employee(db, employee_id, data)
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    return emp

# حذف کارمند
@router.delete("/{employee_id}")
def delete_employee(employee_id: int, db: Session = Depends(get_db)):
    emp = crud.delete_employee(db, employee_id)
    if not emp:
        raise HTTPException(status_code=404, detail="Employee not found")
    return {"message": "Employee deleted successfully"}

# لاگین کارمند
@router.post("/login", response_model=TokenOut)
def login(data: LoginIn, db: Session = Depends(get_db)):
    emp = crud.get_employee_by_username(db, data.username)
    if not emp:
        raise HTTPException(status_code=401, detail="Invalid username or password")

    if not verify_password(data.password, emp.login.password_hash):
        raise HTTPException(status_code=401, detail="Invalid username or password")

    token = create_access_token({"sub": emp.login.username, "role": emp.role})
    return TokenOut(access_token=token, role=emp.role)

# created by: professor zabihullah burhani
# ICT and AI and Robotics متخصص
# phone: 0705002913, email: zabihullahburhani@gmail.com
# Address: Takhar University, COmputer science faculty.

# backend/app/core/config.py
import os

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
DB_FILE = os.path.join(BASE_DIR, "..", "backend.db")  # relative path
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./backend.db")

SECRET_KEY = os.getenv("SECRET_KEY", "supersecretkey_change_me")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24  # 1 day

# backend/app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from app.core import config

engine = create_engine(
    config.DATABASE_URL,
    connect_args={"check_same_thread": False} if config.DATABASE_URL.startswith("sqlite") else {}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Dependency for FastAPI
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# backend/app/core/security.py
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

from jose import jwt, JWTError
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core import config

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)

def create_access_token(claims: Dict[str, Any], expires_minutes: Optional[int] = None) -> str:
    expire = datetime.utcnow() + timedelta(minutes=expires_minutes or config.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode = {**claims, "exp": expire}
    return jwt.encode(to_encode, config.SECRET_KEY, algorithm=config.ALGORITHM)

def decode_token(token: str):
    try:
        payload = jwt.decode(token, config.SECRET_KEY, algorithms=[config.ALGORITHM])
        return payload
    except JWTError:
        return None

# برگرداندن یوزر جاری از روی توکن (بدون نیاز به DB؛ نقش داخل توکن است)
def get_current_user(token: str = Depends(oauth2_scheme)):
    payload = decode_token(token)
    if not payload or "sub" not in payload or "role" not in payload:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired token")
    return {"username": payload["sub"], "role": payload["role"]}

# اجازه ادمین
def require_admin(user=Depends(get_current_user)):
    if user.get("role") != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admin only")
    return user

# created by: professor zabihullah burhani
# ICT and AI and Robotics متخصص
# phone: 0705002913, email: zabihullahburhani@gmail.com
# Address: Takhar University, COmputer science faculty.

# backend/app/crud/user.py
from sqlalchemy.orm import Session
from app.models.user import Employee, Login
from app.schemas.user import EmployeeCreate, EmployeeUpdate
from app.core.security import hash_password
from datetime import datetime

# ایجاد کارمند و رکورد Login
def create_employee(db: Session, emp: EmployeeCreate):
    new_emp = Employee(
        full_name=emp.full_name,
        role=emp.role,
        phone=emp.phone,
        profile_pic=emp.profile_pic,
        created_at=datetime.utcnow()
    )
    db.add(new_emp)
    db.commit()
    db.refresh(new_emp)

    # ایجاد رکورد لاگین
    login = Login(
        employee_id=new_emp.employee_id,
        username=emp.username,
        password_hash=hash_password(emp.password)
    )
    db.add(login)
    db.commit()
    db.refresh(login)

    return new_emp

# گرفتن همه کارمندان
def get_employees(db: Session):
    return db.query(Employee).all()

# گرفتن یک کارمند با ID
def get_employee(db: Session, employee_id: int):
    return db.query(Employee).filter(Employee.employee_id == employee_id).first()

# آپدیت کارمند
def update_employee(db: Session, employee_id: int, data: EmployeeUpdate):
    emp = get_employee(db, employee_id)
    if not emp:
        return None
    if data.full_name is not None:
        emp.full_name = data.full_name
    if data.role is not None:
        emp.role = data.role
    if data.phone is not None:
        emp.phone = data.phone
    if data.profile_pic is not None:
        emp.profile_pic = data.profile_pic
    db.commit()
    db.refresh(emp)
    return emp

# حذف کارمند
def delete_employee(db: Session, employee_id: int):
    emp = get_employee(db, employee_id)
    if not emp:
        return None
    # حذف رکورد Login مربوطه
    login = db.query(Login).filter(Login.employee_id == employee_id).first()
    if login:
        db.delete(login)
    db.delete(emp)
    db.commit()
    return emp

# گرفتن کارمند با username (برای لاگین)
def get_employee_by_username(db: Session, username: str):
    return db.query(Employee).join(Login).filter(Login.username == username).first()

# created by: professor zabihullah burhani
# ICT and AI and Robotics متخصص
# phone: 0705002913, email: zabihullahburhani@gmail.com
# Address: Takhar University, COmputer science faculty.

# app/models/user.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
import datetime
from app.core.database import Base

class Employee(Base):
    __tablename__ = "employees"
    employee_id = Column(Integer, primary_key=True, index=True)
    full_name = Column(String, nullable=False)
    role = Column(String, nullable=False)
    phone = Column(String, nullable=True)
    profile_pic = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)

    login = relationship("Login", uselist=False, back_populates="employee")

class Login(Base):
    __tablename__ = "logins"
    login_id = Column(Integer, primary_key=True, index=True)
    employee_id = Column(Integer, ForeignKey("employees.employee_id"), nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    last_login = Column(DateTime, default=datetime.datetime.utcnow)

    employee = relationship("Employee", back_populates="login")

# created by: professor zabihullah burhani
# ICT and AI and Robotics متخصص
# phone: 0705002913, email: zabihullahburhani@gmail.com
# Address: Takhar University, COmputer science faculty.

# app/schemas/user.py
from pydantic import BaseModel
from typing import Optional

# داده ورودی برای ایجاد کارمند
class EmployeeCreate(BaseModel):
    full_name: str
    role: str
    phone: Optional[str] = None
    username: str
    password: str
    profile_pic: Optional[str] = None  # مسیر عکس پروفایل

# داده ورودی برای ویرایش کارمند
class EmployeeUpdate(BaseModel):
    full_name: Optional[str] = None
    role: Optional[str] = None
    phone: Optional[str] = None
    profile_pic: Optional[str] = None

# داده خروجی کارمند
class EmployeeOut(BaseModel):
    employee_id: int
    full_name: str
    role: str
    phone: Optional[str] = None
    username: str
    profile_pic: Optional[str] = None

    class Config:
        orm_mode = True

# داده برای لاگین
class LoginIn(BaseModel):
    username: str
    password: str

# توکن خروجی بعد از لاگین
class TokenOut(BaseModel):
    access_token: str
    token_type: str = "bearer"
    role: str

# created by: professor zabihullah burhani
# ICT and AI and Robotics متخصص
# phone: 0705002913, email: zabihullahburhani@gmail.com
# Address: Takhar University, COmputer science faculty.

# backend/app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session

from app.core.database import engine, Base, get_db
from app.models import user as models_user
from app.crud import user as crud_user
from app.core.security import hash_password

from app.api.v1 import auth as auth
from app.api.v1 import users as users
# create tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="GJBMS Auth API")

# CORS for frontend on localhost:3000
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],
    allow_credentials=True,

    allow_methods=["*"],
    allow_headers=["*"],
)

# include auth router under /api/v1
app.include_router(auth.router)
app.include_router(users.router)



# backend/alembic.ini
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .


# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.
sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the module runner, against the "ruff" module
# hooks = ruff
# ruff.type = module
# ruff.module = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Alternatively, use the exec runner to execute a binary found on your PATH
# hooks = ruff
# ruff.type = exec
# ruff.executable = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

